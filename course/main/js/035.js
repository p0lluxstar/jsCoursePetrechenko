"use strict";

let a = 5; alert (a++); // 5, потому что сначало будет вывдено значение a, а затем оно увеличится на единицу. Что бы появилась шесть надо плюсы вначало поставить ++5

console.log([ ] + false - null + true ) //NaN. Когда пустой массив скалдаываем с тройкой, этот массив превращается в "", т.е. в пустую строку. Затем когда пустая строка складывается с false, будет NaN, и потом NaN скадываем с true тоже получаем NaN

let y = 1; 
let x = y = 2; 
alert(x); // 2, поскольку числа примитивный тип данных, то присваение идет справа на лево.

console.log([ ] + 1 + 2 ); //"12", масси превращается в пустую строку, затем конкатенация с 1, получаем строку "1", затем снова конкатенация с 2

alert( "1"[0] ); // 1, к строке можно обратиться по индексу. В этом примере "1" имеет индекс 0

console.log(2 && 1 && null && 0 && undefined); //null. оператор && всегда запинается на лжи. 2 правдивое значение, 1 тоже, а null не правдивое. Дальше код не будет выполняться

console.log(!!( 1 && 2 ) === (1 && 2) ); // false. Эти значения не равны. Потому что !! превращает выражает в булиново, а булиново значение не равно значению, которое вернется во вторых скобках

alert( null || 2 && 3 || 4 ); //3.  оператор || запинается на правде. Сначала сработает значение &&, вернется 3, затем null || 3, тоже вернется 3, потому что null не правда, а 3 правда, и послдний действие это будет 3 || 4, вернется 3, потому что оператор запинается на правде, а 3 это правда 

a = [1, 2, 3]; 
b = [1, 2, 3]; 
// a не равно b, это разные массивы просто они содержат одинаковые значения

alert( +"Infinity" ); // Infinity, то только тип данных будет число, потому что +

console.log("Ёжик" > "яблоко");// false, потому что в юникоде сивмол я, считается больше Ё

console.log(0 || "" || 2 || undefined || true || falsе); //2 . Опять срабатывает правиль что || запинается на правде. 0 и "" это ложные значения, а 2 правдивая. Как только код дойдет до 2, он дальше перестанет выполняться